# 并发编程

#### 1、线程上下文切换

线程上下文切换：CPU不再执行当前的线程，而去执行另一个线程的代码。

- 线程的CPU时间片用完
- 垃圾回收 stop the world
- 有更高优先级的线程需要运行
- 线程自己调用了sleep、yield、wait、join、park、synchronized、lock等方法。

当线程上下文切换发生时，需要操作系统保存当前线程的状态，并恢复另一个线程的状态，Java中对应的是程序计数器，它的作用是记住下一条JVM指令的执行地址，线程私有。

- 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等。
- 频繁上下文切换会影响性能。

#### 2、run和start的区别

run方法是线程默认要执行的方法，也是线程执行的入口。

start方法是Thread类的默认执行入口。要使线程Thread启动起来，需要通过start方法，表示线程可执行状态，调用start方法后，则表示Thread开始执行，此时run变成了Thread的默认要执行普通方法。

系统通过调用线程类的start()方法来启动一个线程，此时该线程处于就绪状态，而非运行状态，这也就意味着这个线程可以被JVM来调度执行。

 如果直接调用线程类的run()方法，它就会被当做一个普通的函数调用。

**star()方法可以异步地调用run()方法，但是直接调用run()方法是同步的，因此也就不能达到多线程的目的。** 

#### 3、sleep和yield的区别

sleep：

1. 调用sleep方法会让当前线程从RUNNING进入TIMED_WAITING状态（限制时间的阻塞）
2. 其它线程可以使用interrupt方法打断正在睡眠的线程，sleep方法会抛出 java.lang.InterruptedException: sleep interrupted
3. 睡眠结束之后的线程未必会立刻得到执行，进入就绪状态。
4. 建议使用TimeUnit的sleep代替Thread的sleep来获得更好的可读性。

```java
TimeUnit.SECONDS.sleep(2);
```

yield:

1. 调用yield会让当前线程从RUNNING进入RUNNABLE就绪状态，然后执行其它线程。如果当前没有其它线程，则还是执行该线程。

#### 4、守护线程

​	默认状态下，Java需要等待所有线程运行结束，才会结束。有一种特殊的线程是守护线程，只要非守护线程运行结束，即便守护线程的代码没有执行结束，也会强制结束。

​	例如：

1. 垃圾回收期线程
2. Tomcat中的Acceptor和Poller线程，Tomcat在接收到shutdown命令之后，不会等待它们处理完当前请求。

#### 5、操作系统层面的线程状态

![操作系统线程状态](.\操作系统线程状态.PNG)

1. **初始状态**：仅是在语言层面上创建了线程对象，还未与操作系统关联。
2. **可运行状态**：（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由CPU调度执行。
3. **运行状态**：指获取了CPU时间片运行中的状态。
   - 当CPU时间片用完，会从**运行状态**转换至**可运行状态**。
4. **阻塞状态**：
   - 如果调用了阻塞API，如BIO读写文件，这时该线程实际不会用到CPU，会导致线程上下文切换，进入**阻塞状态**。
   - 等BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至**可运行状态**。
   - 与**可运行状态**的区别是，对**阻塞状态**的线程来说只是它们一直不唤醒，调度器就一直不会考虑调度阻塞线程。

5. **终止状态**：表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态。

